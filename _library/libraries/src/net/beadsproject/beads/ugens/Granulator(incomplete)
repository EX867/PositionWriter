package net.beadsproject.beads.ugens;
//this file was modified from TarsosDSP source. I copy and paste it because beads's granulator cannot be used as just effector.
//(Beads->TarsosDSP->Beads???)

//(modifier) I know nothing about dsp! I am just guessing what it dowes...
import java.util.ArrayList;
import java.util.Arrays;
import beads.AudioContext;
import beads.UGen;
import beads.DataBead;
import beads.DataBeadReceiver;
import beads.Buffer;
import beads.Sample;
import beads.CosineWindow;
import net.beadsproject.beads.ugens.Grain;
/**
 * Granulator plays back samples using granular synthesis.
 * Methods can be used to control playback rate, pitch, grain size,
 *  grain interval and grain randomness and position (this last case assumes that the playback rate is zero).
 * @author ollie
 * @author Joren
 */
 public class Granulator extends UGen {
 	/** The position in milliseconds. */
 	protected double position;
 	/**
 	 * The millisecond position increment per sample. Calculated from the ratio
 	 * of the {@link AudioContext}'s sample rate and the {@link Sample}'s sample
 	 * rate.
 	 */
 	private double positionIncrement;
 	/** The time in milliseconds since the last grain was activated. */
 	private float timeSinceLastGrain;

 	/** The length of one sample in milliseconds. */
 	private double msPerSample;

 	/** The pitch, bound to the pitch envelope. */
 	protected float pitch;

 	/** The list of current grains. */
 	private ArrayList<Grain> grains;

 	/** A list of free grains. */
 	private ArrayList<Grain> freeGrains;

 	/** A list of dead grains. */
 	private ArrayList<Grain> deadGrains;

 	/** The window used by grains. */
 	private Buffer window;

 	/** Flag to determine whether, looping occurs within individual grains. */
 	private boolean loopInsideGrains;

 	private final float[] audioBuffer;
 	private int audioBufferWatermark;
 	private final float[] outputBuffer;

 	private float grainInterval;
 	private float grainSize;
 	private float grainRandomness;
  private float panRandomness;

  public Granulator(AudioContext context, int outs) {
   super(context, outs);
   grains = new ArrayList<Grain>();
   freeGrains = new ArrayList<Grain>();
   deadGrains = new ArrayList<Grain>();
   setGrainInterval(70.0f);//beads
   setGrainSize(100.0f);
   setRandomness(0.0f);
   setRandomPan(0.0f);
   setWindow(new CosineWindow().getDefault());
   msPerSample = context.samplesToMs(1f);
   loopInsideGrains = false;
   		audioBuffer = new float[(int) (12*60*context.getSampleRate())];//max 12 minutes of audio tarsos
   		audioBufferWatermark = 0;
   		pitch = 1.0f;//?
   		outputBuffer = new float[context.getBufferSize()];
   		//msPerSample = 1000.0f/sampleRate;
   		positionIncrement = msPerSample;
 }
 public void setWindow(Buffer window) {
   this.window = window;
 }
 public void setPitch(float pitch) {
   this.pitch = pitch;
 }
 public void setGrainInterval(float grainInterval) {
   this.grainInterval = grainInterval;
 }
 public void setGrainSize(float grainSizeUGen) {
   this.grainSize = grainSizeUGen;
 }
 public void setRandomness(float randomnessUGen) {
   this.grainRandomness = randomnessUGen;
 }
 public void setRandomPan(float randomPanEnvelope) {
   this.randomPan = randomPanEnvelope;
 }
 	public void start() {
 		timeSinceLastGrain = 0;
 	}
  public void clear(){
    grains.clear();
    timeSinceLastGrain = 0f;
  }
  	/** Flag to indicate special case for the first grain. */
  	private boolean firstGrain = true;
  	/** Special case method for playing first grain. */
  	private void firstGrain() {
  		if(firstGrain) {
  			Grain g = new Grain();
  			g.position = position;
  			g.age = grainSize / 4f;
  			g.grainSize = grainSize;

  			grains.add(g);
  			firstGrain = false;
  			timeSinceLastGrain = grainInterval / 2f;
  			g.setGrainPan(randomPanEnvelope.getValue(0, 0),outs);
  		}
  	}
 	public double getFrameLinear(double posInMS) {
 		double result = 0.0;
 		double sampleNumber = msToSamples(posInMS);
 		int sampleNumberFloor = (int) Math.floor(sampleNumber);
 		if (sampleNumberFloor > 0 && sampleNumberFloor < audioBufferWatermark) {
 			double sampleNumberFraction = sampleNumber - sampleNumberFloor;
 			if (sampleNumberFloor == audioBufferWatermark - 1) {
 				result = audioBuffer[sampleNumberFloor];
 			} else {
 				// linear interpolation
 				double current = audioBuffer[sampleNumberFloor];
 				double next = audioBuffer[sampleNumberFloor];
 				result = (float) ((1 - sampleNumberFraction) * current + sampleNumberFraction * next);
 			}
 		}
 		return result;
 	}
 	public float getFrameNoInterp(double posInMS) {
 		double frame = msToSamples(posInMS);
 		int frame_floor = (int) Math.floor(frame);
 		return audioBuffer[frame_floor];
 	}
 	public float getFrameCubic(double posInMS) {
 		float frame = (float) msToSamples(posInMS);
 		float result = 0.0f;
 		float a0, a1, a2, a3, mu2;
 		float ym1, y0, y1, y2;

 		int realCurrentSample = (int) Math.floor(frame);
 		float fractionOffset = (float) (frame - realCurrentSample);

 		if (realCurrentSample >= 0 && realCurrentSample < (audioBufferWatermark - 1)) {
 			realCurrentSample--;
 			if (realCurrentSample < 0) {
 				ym1 = audioBuffer[0];
 				realCurrentSample = 0;
 			} else {
 				ym1 = audioBuffer[realCurrentSample++];
 			}
 			y0 = audioBuffer[realCurrentSample++];
 			if (realCurrentSample >= audioBufferWatermark) {
 				y1 = audioBuffer[audioBufferWatermark-1]; // ??
 			} else {
 				y1 = audioBuffer[realCurrentSample++];
 			}
 			if (realCurrentSample >= audioBufferWatermark) {
 				y2 = audioBuffer[audioBufferWatermark-1];
 			} else {
 				y2 = audioBuffer[realCurrentSample++];
 			}
 			mu2 = fractionOffset * fractionOffset;
 			a0 = y2 - y1 - ym1 + y0;
 			a1 = ym1 - y0 - a0;
 			a2 = y1 - ym1;
 			a3 = y0;
 			result = a0 * fractionOffset * mu2 + a1 * mu2 + a2 * fractionOffset + a3;
 		}
 		return result;
 	}
 	public float getValueFraction(float fraction) {
 		float posInBuf = fraction * window.length;
 		int lowerIndex = (int)posInBuf;
 		float offset = posInBuf - lowerIndex;
 		int upperIndex = (lowerIndex + 1) % window.length;
 		return (1 - offset) * window[lowerIndex] + offset * window[upperIndex];
 	}
 public float getAverageNumberOfGrains() {//beads
   return grainSize / grainInterval;
 }
@Override
public synchronized void calculateBuffer(){
  System.arraycopy(bufIn, 0, audioBuffer,
  audioBufferWatermark, context.getBufferSize());
  audioBufferWatermark += context.getBufferSize();
  // grains.clear();
  // position = audioEvent.getTimeStamp()*1000 - 5000;
  // reset output
  Arrays.fill(outputBuffer, 0);
  firstGrain();
  int bufferSize=context.getBufferSize();
     //now loop through the buffer
     for (int i = 0; i < bufferSize; i++) {
       //determine if we need a new grain
       if (timeSinceLastGrain > grainInterval) {
         Grain g = null;
         if(freeGrains.size() > 0) {
           g = freeGrains.get(0);
           freeGrains.remove(0);
         } else {
           g = new Grain();
         }
         g.reset(grainSize, grainRandomness, position,timeStretchFactor,pitchFactor);
         grains.add(g);
         timeSinceLastGrain = 0f;
       }
       //for each channel, start by resetting current output frame
       for (int j = 0; j < outs; j++) {//beads
         bufOut[j][i] = 0.0f;
       }
       //gather the output from each grain
       for(int gi = 0; gi < grains.size(); gi++) {
         Grain g = grains.get(gi);
         //calculate value of grain window
         float windowScale = window.getValueFraction((float)(g.age / g.grainSize));
         //get position in sample for this grain
         //get the frame for this grain
         switch (interpolationType) {
         case ADAPTIVE:
           if(pitch > ADAPTIVE_INTERP_HIGH_THRESH) {
             sampleValue= getFrameNoInterp(g.position, frame);
           } else if(pitch > ADAPTIVE_INTERP_LOW_THRESH) {
             sampleValeu=getFrameLinear(g.position, frame);
           } else {
             sampleValue=getFrameCubic(g.position, frame);
           }
           break;
         case LINEAR:
           sampleValue= getFrameLinear(g.position, frame);
           break;
         case CUBIC:
           sampleValue=getFrameCubic(g.position, frame);
           break;
         case NONE:
           sampleValue=getFrameNoInterp(g.position, frame);
           break;
         }
         //add it to the current output frame
         for (int j = 0; j < outs; j++) {
           bufOut[j][i] += g.pan[j] * windowScale * frame[j % ins];
         }
       }
       position += positionIncrement * timeStretchFactor;//tarsos
       //increment time and stuff
       calculateNextPosition(i);//beads
       for(int gi = 0; gi < grains.size(); gi++) {
         Grain g = grains.get(gi);
         calculateNextGrainPosition(g);
       }
       //increment timeSinceLastGrain
       timeSinceLastGrain += msPerSample;
       //finally, see if any grains are dead
       for(int gi = 0; gi < grains.size(); gi++) {
         Grain g = grains.get(gi);
         if(g.age > g.grainSize) {
           freeGrains.add(g);
           deadGrains.add(g);
         }
       }
       for(int gi = 0; gi < deadGrains.size(); gi++) {
         Grain g = deadGrains.get(gi);
         grains.remove(g);
       }
       deadGrains.clear();
     }
   }
  private void calculateNextGrainPosition(Grain g) {//beads
    int direction = rate >= 0 ? 1 : -1;	//this is a bit odd in the case when controlling grain from positionEnvelope
    g.age += msPerSample;
    g.position += direction * positionIncrement * pitchFactor;//tarsos
    /*if(loopInsideGrains) {
      switch(loopType) {
      case NO_LOOP_FORWARDS:
        position += direction * positionIncrement * pitch;
        break;
      case NO_LOOP_BACKWARDS:
        position -= direction * positionIncrement * pitch;
        break;
      case LOOP_FORWARDS:
        position += direction * positionIncrement * pitch;
        if(rate > 0 && position > Math.max(loopStart, loopEnd)) {
          position = Math.min(loopStart, loopEnd);
        } else if(rate < 0 && position < Math.min(loopStart, loopEnd)) {
          position = Math.max(loopStart, loopEnd);
        }
        break;
      case LOOP_BACKWARDS:
        position -= direction * positionIncrement * pitch;
        if(rate > 0 && position < Math.min(loopStart, loopEnd)) {
          position = Math.max(loopStart, loopEnd);
        } else if(rate < 0 && position > Math.max(loopStart, loopEnd)) {
          position = Math.min(loopStart, loopEnd);
        }
        break;
      case LOOP_ALTERNATING:
        position += direction * (forwards ? positionIncrement * pitch : -positionIncrement * pitch);
        if(forwards ^ (rate < 0)) {
          if(position > Math.max(loopStart, loopEnd)) {
            position = 2 * Math.max(loopStart, loopEnd) - position;
          }
        } else if(position < Math.min(loopStart, loopEnd)) {
          position = 2 * Math.min(loopStart, loopEnd) - position;
        }
        break;
      }
    } else {
      position += direction * positionIncrement * pitch;
    }*/
  }
 }
